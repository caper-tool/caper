module Caper.RegionInterpretations where

import Control.Monad.Reader
import Control.Monad.State
import qualified Data.Set as Set
import qualified Data.Map as Map
import Control.Lens

import qualified Caper.Parser.AST.Annotation as AST
import Caper.ProverDatatypes
import Caper.RegionTypes
import Caper.SymbolicState
import Caper.Exceptions
import Caper.Logger
import Caper.Assertions
import Caper.Prover

-- Actually, this is probably part of the AST...
data StateInterpretation = StateInterpretation {
        siConditions :: [AST.PureAssrt],
        siState :: AST.ValExpr,
        siInterp :: AST.Assrt
        }

siVariables :: StateInterpretation -> Set.Set (Maybe String)
siVariables si = Set.union (freeVariables (siConditions si))
                        (freeVariables (siState si))

-- |Check if each state that matches the state interpretation is unambiguously
-- generated by a valuation of the variables.  This check is conservative.
checkStateInterpretationSelfAmbiguity ::
        (MonadRaise m, MonadIO m, MonadLogger m,
        MonadReader r m, Provers r) =>
        [String] -- ^The region parameters
        -> StateInterpretation
                -- ^The state interpretation to check for self-ambiguity
        -> m ()
checkStateInterpretationSelfAmbiguity params si@(StateInterpretation cs se _) =
                flip evalStateT (fmap emptyAssertions emptySymbState) $ do
                        -- Produce the parameters
                        mapM_ produceVariable
                                [AST.Variable undefined x | x <- params]
                        savedVars <- use logicalVars
                        -- Produce the conditions once
                        mapM_ producePure cs
                        state1 <- produceValueExpr se
                        vars1 <- use logicalVars
                        logicalVars .= savedVars
                        -- Produce the conditions again, but with different
                        -- variables
                        mapM_ producePure cs
                        vars2 <- use logicalVars
                        state2 <- produceValueExpr se
                        -- Assume the states are equal
                        assumeTrueE $ VAEq state1 state2
                        -- Now assert that the variables are equal
                        forM_ (Map.toList vars1) $ \(vn, v1) -> do
                                let v2 = Map.findWithDefault
                                        (error $ "checkStateInterpretationSelfAmbiguity: no second binding for " ++ vn)
                                        vn vars2
                                assertTrueE $ EqualityCondition v1 v2
                        r <- checkAssertions
                        unless r $ raise OverlappingStateInterpretation
       